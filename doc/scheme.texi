@chapter Festival's Scheme Programming Language

This chapter acts as a reference guide for the particular dialect of
the Scheme programming language used in the Festival Speech Synthesis
systems.  The Scheme programming language is a dialect of Lisp
designed to be more consistent.  It was chosen for the basic
scripting language in Festival because:
@itemize @bullet
@item 
it is a very easy language for machines to parse and interpret, thus
the foot print for the interpreter proper is very small
@item 
it offers garbage collection making managing objects safe and easy.
@item 
it offers a general consistent datastructure for representing parameters,
rules etc.
@item
it was familiar to the authors
@item
its is suitable for use as an embedded system
@end itemize
Having a scripting language in Festival is actually one of the
fundamental properties that makes Festival a useful system.  The fact
that new voices and languages in many cases can be added without
changing the underlying C++ code makes the system mouch more powerful
and accessible than a more monolithic system that requires recompilation
for any parameter changes.  As there is sometimes confusion we
should make it clear that Festival contains its own Scheme interpreter
as part of the system.  Festival can be view as a Scheme interpreter
that has had basic addition to its function to include modules
that can do speech synthesis, no external Scheme interperter is
required to use Festival.

The actual interpreter used in Festival is based on George Carret's
SIOD, "Scheme in one Defun".  But this has been substantially enhanced
from its small elegant beginnings into something that might be better
called "Scheme in one directory".  Although there is a standard for
Scheme the version in Festival does not fully follow it, for both good
and bad reasons.  Thus finding in order for people to be able to program
in Festival's Scheme we provide this chapter to list the core type,
functions, etc and some examples.  We do not pretend to be teaching
programming here but as we know many people who are interested in
building voices are not primarily programmers, some guidance on the
language and its usage will make the simple programming that is
required in building voices, more accessible.

For reference the Scheme Revised Revised Revised report describes the
standard definition @cite{srrrr90}.  For a good introduction to
programming in general that happens to use Scheme as its example
language we recommend @cite{abelson85}.  Also for those who are
unfamiliar with the use of Lisp-like scripting languages we recommend a
close look as GNU Emacs which uses Lisp as its underlying scripting
language, knowledge of the internals of Emacs did to some extent
influence the scripting language design of Festival.

@section Overview

"Lots of brackets" is what comes to most people's minds when considering
Lisp and its various derivatives such as Scheme.  At the start this can
seem daunting and it is true that parenthesis errors can cuase problems.
But with an editor that does proper bracket matching, brackets can
actually be helpful in code structure rather than a hindrance.

The fundamental structure is the @emph{s-expression}.  It consists of an
atom, or a list of s-expressions.  This simply defined recursive
structure allows complex structures to easily be specified.  For
example
@lisp
3
(1 2 3)
(a (b c) d)
((a b) (d e))
@end lisp
Unlike other programming languages Scheme's data and code are
in the same format, s-expressions.  Thus s-expression
are evaluated, recursively.
@table @emph
@item Symbols:
are treated as variables and evaluated return their currently set value.
@item Strings and numbers:
evalutate to themselves.
@item Lists:
The each member of the list is evaluated and the first item in
the list is treated as a function and applied using the remainer of the
list as arguments to the function.
@end table
Thus the s-expression 
@lisp
(+ 1 2)
@end lisp
when evaluated will return @code{3} as the symbol @code{+}
is bound to a function that adds it arguments.

Variables may be set using the @code{set!} function which takes
a variable name and a value as arguments
@lisp
(set! a 3)
@end lisp
The @code{set!} function is unusual in that it does not evaluate its
first argument.  If it did you have to explcitly quote it or set some
other variable to have a value of @code{a} to get the desired effect.

quoting, define

@section Data Types

There a number of basic data types in this Scheme, new ones may also be
added but only through C++ functions.  This basic types are
@table @emph
@item Symbols:
symbols atoms starting with an alphabetic character.  Unlike
numbers and strings, they may be used as variables.  Examples
are 
@lisp
a bcd f6 myfunc 
plus cond
@end lisp
Symbols may be created from strings by using the function @code{intern}
@item Numbers:
In this version of scheme all numbers are doubles, there is no
distinction between floats, doubles and ints.  Examples are
@lisp
1
1.4
3.14
345
3456756.4345476
@end lisp
Numbers evaluate to themselves, that is the value of the atom 2
is the number 2.
@item Strings:
Strings are bounded by the double quote characters @code{"}.  For
example
@lisp
"a"
"abc"
"This is a string"
@end lisp
Strings evaluate to themselves.  They may be converted to symbols
with the function @code{intern}.  If they are strings of characaters
that represent numbers you can convert a string to a number with 
the function @code{parse-number}.  For example
@lisp
(intern "abc") => abc
(parse-number "3.14") => 3.14
@end lisp
Although you can make symbols from numbers you should not do that.

Double quotes may be specified within a string by escaping it with a
backslash.  Backslashes therefore also require an escape backslash.
That is, @code{"ab\"c"} contains four characters, @code{a}, @code{b},
@code{"} and @code{c}.  @code{"ab\\c"} also contains four characters,
@code{a}, @code{b}, @code{\} and @code{c}.  And @code{"ab\\\"c"}
contains five characters @code{a}, @code{b}, @code{\}, @code{"} and
@code{c}.
@item Lists or Cons
Lists start with a left parenthesis and end with a right parenthesis
with zero or more s-expression between them.  For example
@lisp
(a b c)
()
(b (b d) e)
((the boy) saw (the girl (in (the park))))
@end lisp
Lists can be made by various functions most notably @code{cons} and
@code{list}.  @code{cons} returns a list whose first item is the first
item in the list, standardly called its @code{car}, and whose remainder,
standardly called its @code{cdr}, is the second argument of @code{cons}.
@lisp
(cons 'a '(b c)) => (a b c)
(cons '(a b) '(c d)) => ((a b) c d)
@end lisp
@item Functions:
Functions may be applied explicity bu the function @code{apply}
or more normally as when the appear as the first item in a list
to be evaluated.  The normal way to define function is using
the @code{define} function.  For example
@lisp
(define (ftoc temp)
   (/ (* (- temp 32) 5) 9))
@end lisp
This binds the function to the variable @code{ftoc}.  Functions
can also be defined anonymously which sometimes is convinient.
@lisp
(lambda (temp)
   (/ (* (- temp 32) 5) 9))
@end lisp
returns a function.
@item Others:
other internal types are support by Festival's scheme including some
inportant object types use for synthesis such as utterances, waveforms,
items etc.  The are normally printed as in the form
@lisp
#<Utterance 6234>
#<Wave 1294>
@end lisp
The rpint form is a convinience form only.  Enter that string of
characters will not allow a reference to that object.  The number is
unique to that object instance (it is actually the internal address of
the object), and can be used visually to note if objects are the same or
not.
@end table

@section Functions

This section lists the basic functions in Festival's Scheme.  It doesn't
list them all (see the Festival manual for that) but does highlight the
key functions that you should normally use.

@subsection Core functions

These functions are the basic functions used in Scheme.  These
include the structural functions for setting variables, 
conditionals. loops, etc.

@table @code
@item (set! SYMBOL VALUE)
Sets @var{SYMBOL} to @var{VALUE}.  @var{SYMBOL} is not evaluated,
while @var{VALUE} is.  Example
@lisp
(set! a 3)
(set! pi 3.14)
(set! fruit '(apples pears bananas))
(set! fruit2 fruit)
@end lisp
@item (define (FUNCNAME ARG0 ARG1 ...) . BODY)
define a function called @var{FUNCNAME} with specified arguments and
body.
@lisp
(define (myadd a b) (+ a b))
(define (factorial a)
 (cond
  ((< a 2) 1)
  (t (* a (factorial (- a 1))))))
@end lisp
@item (if TEST TRUECASE [FALSECASE] )
If the value of @var{TEST} is non-nil, evaluate @var{TRUECASE} and return
value else if present evaluate @var{FALSECASE} if present and return value,
else return @code{nil}.
@lisp
(if (string-equal v "apples")
   (format t "It's an apple\n")
   (format t "It's not an apple\n"))
(if (member v '(apples pears bananas))
   (begin
       (format t "It's a fruit (%s)\n" v)
       'fruit)
   'notfruit)
@end lisp
@item (cond (TEST0 . BODY) (TEST1 . BODY) ...)
A multiple if statement.  Evaluates each @var{TEST} until a non-nil test
is found then evalues each of the expressions in that @var{BODY} return
the value of the last one.
@lisp
(cond
  ((string-equal v "apple")
   'ringo)
  ((string-equal v "plum")
   'ume)
  ((string-equal v "peach")
   'momo)
  (t
   'kudamono)
@end lisp
@item (begin . BODY )
This evaluates each s-expression in @var{BODY} and returns the value
of the last s-expression in the list.  This is useful for case
where only one s-expression is expected but you need to call a number
of functions, notably the @code{if} function.
@lisp
(if (string-equal v "pear")
    (begin
       (format t "assuming it's a asian pear\n")
       'nashi)
    'kudamono)
@end lisp
@item (or . DISJ)
evalutate each disjunct until one is non-nil and return that value.
@lisp
(or (string-equal v "tortoise")
    (string-equal v "turtle"))
(or (string-equal v "pear")
    (string-equal v "apple")
    (< num_fruits 6))
@end lisp
@item (and . CONJ)
evalutate each conjunct until one is nil and return that value or
return the value of the last conjunct.
@lisp
(and (< num_fruits 10)
     (> num_fruits 3))
(and (string-equal v "pear")
     (< num_fruits 6)
     (or (string-equal day "Tuesday")
         (string-equal day "Wednesday")))
@end lisp
@end table

@subsection List functions

@table @code
@item (car EXPR)
returns the "car" of @var{EXPR}, for a list this is the first item,
for an atom or the empty list this is defined to be @code{nil}.
@lisp
(car '(a b)) => a
(car '((a b) c d)) => (a b)
(car '(a (b c) d)) => a
(car nil) => nil
(car 'a) => nil
@end lisp
@item (cdr EXPR)
returns the "cdr" of @var{EXPR}, for a list this is the rest of the
list, for an atom or the empty list this is defined to be @code{nil}.
@lisp
(cdr '(a b)) => (b)
(cdr '((a b) c d)) => (c d)
(cdr '(a)) => nil
(cdr '(a (b c))) => ((b c))
(cdr nil) => nil
(cdr 'a) => nil
@end lisp
@item (cons EXPR0 EXPR2)
build a new list whose "car" is @var{EXPR0} and whose "cdr" is @var{EXPR1}.
@lisp
(cons 'a '(b c)) => (a b c)
(cons 'a ()) => (a)
(cons '(a b) '(c d) => '((a b) c d))
(cons () '(a) => '(nil a))
(cons 'a 'b => (a . b))
(cons nil nil) => (nil)
@end lisp
@item (list . BODY)
Form a list from each of the arguments
@lisp
(list 'a 'b 'c) => (a b c)
(list '(a b) 'c 'd) => ((a b) c d)
(list nil '(a b) '(a b)) => (nil (a b) (a b))
@end lisp
@item (append . BODY)
Join each of the arguments (lists) into a single list
@lisp
(append '(a b) '(c d)) => (a b c d)
(append '(a b) '((c d)) '(e f)) => (a b (c d) e f)
(append nil nil) => nil
(append '(a b)) => (a b))
(append 'a 'b) => error
@end lisp
@item (nth N LIST)
Return Nth member of list, the first item is the 0th member.
@lisp
(nth 0 '(a b c)) => a
(nth 2 '(a b c)) => c
(nth 3 '(a b c)) => nil
@end lisp
@item (nth_cdr N LIST)
Return Nth cdr list, the first cdr is the 0th member, which is
the list itself.
@lisp
(nth 0 '(a b c)) => (a b c)
(nth 2 '(a b c)) => (c)
(nth 1 '(a b c)) => (b c)
(nth 3 '(a b c)) => nil
@end lisp
@item (last LIST)
The last cdr of a list, traditionally this function has always been called
@code{last} rather @code{last_cdr}
@lisp
(last '(a b c)) => (c)
(last '(a b (c d))) => ((c d))
@end lisp
@item (reverse LIST)
Return the list in reverse order
@lisp
(reverse '(a b c)) => (c b a)
(reverse '(a)) => (a)
(reverse '(a b (c d))) => ((c d) b a)
@end lisp
@item (member ITEM LIST)
Returns the cdr in LIST whose car is ITEM or nil if it found
@lisp
(member 'b '(a b c)) => (b c)
(member 'c '(a b c)) => (c)
(member 'd '(a b c)) => nil
(member 'b '(a b c b)) => (b c b)
@end lisp
Note that @code{member} uses @code{eq} to test equality, hence this
does not work for strings.   You should use @code{member_string}
if the list contains strings.
@item (assoc ITEM ALIST)
a-list are a standard list format for representing feature value
pairs.  An a-list is basically a list of pairs of name and value,
although the name may be any lisp item it is usually an symbol.  A
typlical a-list is
@lisp
((name AH)
 (duration 0.095)
 (vowel +)
 (occurs ("file01" "file04" "file07" "file24"))
)
@end lisp
@code{assoc} is a function that allows you to look up values
in an a-list
@lisp
(assoc 'name '((name AH) (duration 0.95))) => (name AH)
(assoc 'duration '((name AH) (duration 0.95))) => (duration 0.95)
(assoc 'vowel '((name AH) (duration 0.95))) => nil
@end lisp
Note that @code{assoc} uses @code{eq} to test equality, hence this
does not work names that are strings.   
You should use @code{assoc_string} if the a-list uses strings for
names.
@end table

@subsection Arithmetic functions

+ - * / exp log sqrt < > <= >= = 

@subsection I/O functions

File names in Festival use the Unix convention of using "/" as the
directory separator.  However under other operating systems, such as
Windows, the "/" will be appropriately mapped into backslash as
required.  For most cases you do not need to worry about this and if you
use forward slash all the time ti will work.

@table @code
@item (format FD FORMATSTRING . ARGS)
The @code{format} function is a littel unusually in Lisp.  It basically
follows the @code{printf} command in C, or more closely follows the
@code{format} function in Emacs lisp.  It is desgined to print out
infomation that isn;t necessarily to be read in by Lisp (unlike
@code{pprint}, @code{print} and @code{printfp}).  @var{FD} is a file
descriptor as created by @code{fopen}, and the result is printed to
that.  Also two special values are allows there.  @code{t} causes the
output to be sent to standard out (which is usually the terminal).
@code{nil} causes the output to be written to a string and returned by
the function.  Also the variable @code{stderr} is set to a file
descriptor for standard error output.

The format string closely follows the format used in C's printf
functions.  It is actually interpreted by those functions in its
implementation.  @code{format} supports the following directives
@table @emph
@item %d
Print as integer
@item %d
Print as integer in hexadecimal
@item %f
Print as float
@item %s
Convert item to string
@item %%
A percent character
@item %g
Print as double
@item %c
Print number as character
@item %l
Print as Lisp object
@end table
In addition directive sizes are supported, including (zero or space)
padding, and widths.  Explicitly specified sizes as arguments as in
@code{%*s} are not supported, nor is @code{%p} for pointers.

The @code{%s} directive will try to convert the corresponding
lisp argument to a string before passing it to the low level print
function.  Thus list will be printed to strings, and numbers also
coverted.  This form will loose the distinction between lisp symbols 
and lisp strings as the quote will not be present in the @code{%s} 
form.  In general @code{%s} should be used for getting nice human
output and not for machine readable output as it is a lossy print
form.

In contrast @code{%l} is designed to reserve the Lisp forms
so they can be more easily read, quotes will appear and escapes
for embedded quote will be treated properly.
@lisp
(format t "duration %0.3f\n" 0.12345) => duration 0.123
(format t "num %d\n" 23) => num 23
(format t "num %04d\n" 23) => num 0023
@end lisp

@item (pprintf SEXP [FD])
Pretty print give expression to standard out (or FD if specified).
Pretty printing is a technique that inserts newlines in the
printout and indentation to make the lisp expression easier to 
read.

@item (fopen FILENAME MODE)
This creates a file description, which can be used in the various I/O
functions.  It closely follows C stdio @code{fopen} function.  The
mode may be
@table @emph
@item "r"
to open the file for reading
@item "w"
to open the file for writing
@item "a"
to open the file at the end for writing (so-called, append).
@item "b"
File I/O in binary (for OS's that make the distinction),
@end table
Or any combination of these.
@item (fclose FD)
Close a file descriptor as created by @code{fopen}.
@item (read)
Read next s-expression from standard in
@item (readfp FD)
Read next s-expression from given file descriptor FD.  On end of
file it returns an sexpression eq to the value returned by the
function @code{(eof_val)}.  A typical example use of these
functions is
@example
(let ((ifd (fopen infile "r"))
      (ofd (fopen outfile "w"))
      (word))
   (while (not (equal? (set! word (readfp ifd)) (eof-val)))
      (format ofd "%l\n" (lex.lookup word nil)))
   (fclose ifd)
   (fclose ofd)))
@end example
@item (load FILENAME [NOEVAL])
Load in the s-expressions in @code{FILENAME}.  If @code{NOEVAL} is
unspecified the s-expressions are evaluated as they are read.  If 
@code{NOEVAL} is specified and non-nil, @code{load} will return all
s-expressions in the file un-evaluated in a single list.
@end table

@subsection String functions

As in many other languages, Scheme has a distinction between
@code{strings} and @code{symbols}.  String evaluate to themselves and
cannot be assigned other values, symbols of the print name are
@code{equal?} while strings of teh same name aren't necessarily.

In Festival's Scheme, strings are eight bit clean and designed to hold
strings of text and characters in what ever language is being
synthesized.  Strings are always treats as string of 8 bit characters
even though some language may interpret these are 16-bit characters.
Symbols, in general, should not contain 8bit characters.
@table @code
@item (string-equal STR1 STR2)
Finds the string of @code{STR1} and @code{STR2} and returns @code{t} if
these are equal, and @code{nil} otherwise.  Symbol names and numbers are
mapped to string, though you should be aware that the mapping of a
number to a string may not always produce what you hope for.  A number
@code{0} may or may not be mapped to @code{"0"} or maybe to @code{"0.0"}
such that you should not dependent on the mapping.  You can use
@code{format} to map a number ot a string in an explicit manner.  It is
however safe to pass symbol names to @code{string-equal}.  In most cases
@code{string-equal} is the right function to use rather than
@code{equal?} which is must stricter about its definition of equality.
@example
(string-equal "hello" "hello") => t
(string-equal "hello" "Hello") => false
(string-equal "hello" 'hello) => t
@end example
@item (string-append . ARGS)
For each argument coerce it to a string, and return the concatenation of
all arguments.
@example
(string-append "abc" "def") => "abcdef"
(string-append "/usr/local/" "bin/" "festival") => "/usr/local/bin/festival"
(string-append "/usr/local/" t 'hello) => "/usr/local/thello"
(string-append "abc") => "abc"
(string-append ) => ""
@end example
@item (member_string STR LIST)
returns @code{nil} if no member of @code{LIST} is @code{string-equal} to
@code{STR}, otherwise it returns @code{t}.  Again, this is often the
safe way to check membership of a list as this will work properly if
@code{STR} or the members of @code{LIST} are symbols or strings.
@example
(member_string "a" '("b" "a" "c")) => t
(member_string "d" '("b" "a" "c")) => nil
(member_string "d" '(a b c d)) => t
(member_string 'a '("b" "a" "c")) => t
@end example
@item (string-before STR SUBSTR)
Returns the initial prefix of @code{STR} up to the first occurrence
of @code{SUBSTR} in @code{STR}.  If @code{SUBSTR} doesn't
exist within @code{STR} the empty string is returned.
@example
(string-before "abcd" "c") => "ab"
(string-before "bin/make_labs" "/") => "bin"
(string-before "usr/local/bin/make_labs" "/") => "usr"
(string-before "make_labs" "/") => ""
@end example
@item (string-after STR SUBSTR)
Returns the longest suffix of @code{STR} after the first occurrence
of @code{SUBSTR} in @code{STR}.  If @code{SUBSTR} doesn't
exist within @code{STR} the empty string is returned.
@example
(string-after "abcd" "c") => "d"
(string-after "bin/make_labs" "/") => "make_labs"
(string-after "usr/bin/make_labs" "/") => "bin/make_labs"
(string-after "make_labs" "/") => ""
@end example
@item (length STR)
Returns the lengh of given string (or list).  Length does not coerce its
argument into a string, hence given a symbol as argument is an error.
@example
(length "") => 0
(length "abc") => 3
(length 'abc) -> SIOD ERROR
(length '(a b c)) -> 3
@end example
@item (symbolexplode SYMBOL)
returns a list of single character strings for each character in
@code{SYMBOL}'s print name.  This will also work on strings.
@example
(symbolexplode 'abc) => ("a" "b" "c")
(symbolexplode 'hello) => ("h" "e" "l" "l" "o")
@end example
@item (intern STR)
Convert a string into a symbol with the same print name.
@item (string-matches STR REGEX)
Returns @code{t} if @code{STR} matches @code{REGEX} regular expression.
Regular expressions are described more fully below.
@example
(string-matches "abc" "a.*") => t
(string-matches "hello" "[Hh]ello") => t
@end example
@end table

@subsection System functions

In order to interact more easily with the underlying operating system,
Festival Scheme includes a number of basic function that allow Scheme
programs to make use of the operating system functions.
@table @code
@item (system COMMAND)
Evaluates the command with the Unix shell (or equivalent).  Its
not clear how this should (or does0 work on other operating systems
so it should be used sparingly if the code is to be portable.
@example
(system "ls") => lists files in current directory.
(system (format nil "cat %s" filename))
@end example
@item (get_url URL OFILE)
Copies contents of @code{URL} into @code{OFILE}.  It support
@file{file:} and @file{http:} prefixes, but current does not support the
@code{ftp:} protocol.  
@example
(get_url "http://www.cstr.ed.ac.uk/projects/festival.html" "festival.html")
@end example
@item (setenv NAME VALUE)
Set environment variable @code{NAME} to @code{VALUE} which should 
be strings
@example
(setenv "DISPLAY" "nara.mt.cs.cmu.edu:0.0")
@end example
@item (getenv NAME)
Get value of environment variable @code{NAME}.
@example
(getenv "DISPLAY")
@end example
@item (getpid)
The process id, as a number.  This is useful when creating
files that need to be unique for the festival instance.
@example
(set! bbbfile (format nil "/tmp/stuff.%05d" (getpid)))
@end example
@item (cd DIRECTORY)
Change directory.
@example
(cd "/tmp")
@end example
@item (pwd)
return a string which is a pathname to the current working directory.
@end table

@subsection Utterance Functions

@subsection Synthesis Functions

@section Debugging and Help

@section Adding new C++ functions to Scheme

@section Regular Expressions

Regular expressions are fundamentally useful in any text processing
language.  This is also true in Festival's Scheme.  The function
@code{string-matches} and a number of other places (notably CART trees)
allow th eunse of regular expressions to matche strings.

We will not go into the formal aspects of regular expressions
but just give enough discussion to help you use them here.  See
@cite{regexbook} for probablay more information than you'll ever
need.

Each implementation of regex's may be slightly different hence here we
will lay out the full syntaxt and semantics of the our regex patterns.
This is not an arbitrary selection, when Festival was first developed we
use the GNU libg++ @code{Regex} class but for portability to non-GNU
systems we had replace that with our own impelementation based on Henry
Spencer regex code (which is at the core of many regex libraries).

In general all character match themselves except for the following
which (can) have special interpretations
@example
. * + ? [ ] - ( ) | ^ $ \
@end example
If these are preceded by a backslash then they no longer will have
special interpretation.
@table @code
@item .
Matches any character.
@example
(string-matches "abc" "a.c") => t
(string-matches "acc" "a.c") => t
@end example
@item *
Matches zero or more occurrences of the preceding item in the regex
@example
(string-matches "aaaac" "a*c") => t
(string-matches "c" "a*c") => t
(string-matches "anythingc" ".*c") => t
(string-matches "canythingatallc" "c.*c") => t
@end example
@item +
Matches one or more occurrences of the preceding item in the regex
@example
(string-matches "aaaac" "a+c") => t
(string-matches "c" "a*c") => nil
(string-matches "anythingc" ".+c") => t
(string-matches "c" ".+c") => nil
(string-matches "canythingatallc" "c.+c") => t
(string-matches "cc" "c.+c") => nil
@end example
@item ?
Matches zero or one occurrences of the preceding item.  This
is it makes the preceding item optional.
@example
(string-matches "abc" "ab?c") => t
(string-matches "ac" "ab?c") => t
@end example
@item [ ]
can defined a set of characters.  This can also be used to defined
a range.  For example @code{[aeiou]} is and lower case vowel, @code{[a-z]}
is an lower case letter from a thru z.  @code{[a-zA-Z]} is any character
upper or lower case.

If the @code{^} is specifed first it negates the class, thus
@code{[^a-z]} matches anything but a lower case character.
@end table

@section Some Examples

