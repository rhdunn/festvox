<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.52
     from ../doc/festvox.texi on 2 August 2000 -->

<TITLE>Building Voices in the Festival Speech Synthesis System - 6  Festival's Scheme Programming Language</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
Go to the <A HREF="festvox_1.html">first</A>, <A HREF="festvox_5.html">previous</A>, <A HREF="festvox_7.html">next</A>, <A HREF="festvox_21.html">last</A> section, <A HREF="festvox_toc.html">table of contents</A>.
<P><HR><P>


<H1><A NAME="SEC16" HREF="festvox_toc.html#TOC16">6  Festival's Scheme Programming Language</A></H1>

<P>
This chapter acts as a reference guide for the particular dialect of
the Scheme programming language used in the Festival Speech Synthesis
systems.  The Scheme programming language is a dialect of Lisp
designed to be more consistent.  It was chosen for the basic
scripting language in Festival because:

<UL>
<LI>

it is a very easy language for machines to parse and interpret, thus
the foot print for the interpreter proper is very small
<LI>

it offers garbage collection making managing objects safe and easy.
<LI>

it offers a general consistent datastructure for representing parameters,
rules etc.
<LI>

it was familiar to the authors
<LI>

its is suitable for use as an embedded system
</UL>

<P>
Having a scripting language in Festival is actually one of the
fundamental properties that makes Festival a useful system.  The fact
that new voices and languages in many cases can be added without
changing the underlying C++ code makes the system mouch more powerful
and accessible than a more monolithic system that requires recompilation
for any parameter changes.  As there is sometimes confusion we
should make it clear that Festival contains its own Scheme interpreter
as part of the system.  Festival can be view as a Scheme interpreter
that has had basic addition to its function to include modules
that can do speech synthesis, no external Scheme interperter is
required to use Festival.

</P>
<P>
The actual interpreter used in Festival is based on George Carret's
SIOD, "Scheme in one Defun".  But this has been substantially enhanced
from its small elegant beginnings into something that might be better
called "Scheme in one directory".  Although there is a standard for
Scheme the version in Festival does not fully follow it, for both good
and bad reasons.  Thus finding in order for people to be able to program
in Festival's Scheme we provide this chapter to list the core type,
functions, etc and some examples.  We do not pretend to be teaching
programming here but as we know many people who are interested in
building voices are not primarily programmers, some guidance on the
language and its usage will make the simple programming that is
required in building voices, more accessible.

</P>
<P>
For reference the Scheme Revised Revised Revised report describes the
standard definition <CITE>srrrr90</CITE>.  For a good introduction to
programming in general that happens to use Scheme as its example
language we recommend <CITE>abelson85</CITE>.  Also for those who are
unfamiliar with the use of Lisp-like scripting languages we recommend a
close look as GNU Emacs which uses Lisp as its underlying scripting
language, knowledge of the internals of Emacs did to some extent
influence the scripting language design of Festival.

</P>


<H2><A NAME="SEC17" HREF="festvox_toc.html#TOC17">6.1  Overview</A></H2>

<P>
"Lots of brackets" is what comes to most people's minds when considering
Lisp and its various derivatives such as Scheme.  At the start this can
seem daunting and it is true that parenthesis errors can cuase problems.
But with an editor that does proper bracket matching, brackets can
actually be helpful in code structure rather than a hindrance.

</P>
<P>
The fundamental structure is the <EM>s-expression</EM>.  It consists of an
atom, or a list of s-expressions.  This simply defined recursive
structure allows complex structures to easily be specified.  For
example

<PRE>
3
(1 2 3)
(a (b c) d)
((a b) (d e))
</PRE>

<P>
Unlike other programming languages Scheme's data and code are
in the same format, s-expressions.  Thus s-expression
are evaluated, recursively.
<DL COMPACT>

<DT><EM>Symbols:</EM>
<DD>
are treated as variables and evaluated return their currently set value.
<DT><EM>Strings and numbers:</EM>
<DD>
evalutate to themselves.
<DT><EM>Lists:</EM>
<DD>
The each member of the list is evaluated and the first item in
the list is treated as a function and applied using the remainer of the
list as arguments to the function.
</DL>
<P>
Thus the s-expression 

<PRE>
(+ 1 2)
</PRE>

<P>
when evaluated will return <CODE>3</CODE> as the symbol <CODE>+</CODE>
is bound to a function that adds it arguments.

</P>
<P>
Variables may be set using the <CODE>set!</CODE> function which takes
a variable name and a value as arguments

<PRE>
(set! a 3)
</PRE>

<P>
The <CODE>set!</CODE> function is unusual in that it does not evaluate its
first argument.  If it did you have to explcitly quote it or set some
other variable to have a value of <CODE>a</CODE> to get the desired effect.

</P>
<P>
quoting, define

</P>


<H2><A NAME="SEC18" HREF="festvox_toc.html#TOC18">6.2  Data Types</A></H2>

<P>
There a number of basic data types in this Scheme, new ones may also be
added but only through C++ functions.  This basic types are
<DL COMPACT>

<DT><EM>Symbols:</EM>
<DD>
symbols atoms starting with an alphabetic character.  Unlike
numbers and strings, they may be used as variables.  Examples
are 

<PRE>
a bcd f6 myfunc 
plus cond
</PRE>

Symbols may be created from strings by using the function <CODE>intern</CODE>
<DT><EM>Numbers:</EM>
<DD>
In this version of scheme all numbers are doubles, there is no
distinction between floats, doubles and ints.  Examples are

<PRE>
1
1.4
3.14
345
3456756.4345476
</PRE>

Numbers evaluate to themselves, that is the value of the atom 2
is the number 2.
<DT><EM>Strings:</EM>
<DD>
Strings are bounded by the double quote characters <CODE>"</CODE>.  For
example

<PRE>
"a"
"abc"
"This is a string"
</PRE>

Strings evaluate to themselves.  They may be converted to symbols
with the function <CODE>intern</CODE>.  If they are strings of characaters
that represent numbers you can convert a string to a number with 
the function <CODE>parse-number</CODE>.  For example

<PRE>
(intern "abc") =&#62; abc
(parse-number "3.14") =&#62; 3.14
</PRE>

Although you can make symbols from numbers you should not do that.

Double quotes may be specified within a string by escaping it with a
backslash.  Backslashes therefore also require an escape backslash.
That is, <CODE>"ab\"c"</CODE> contains four characters, <CODE>a</CODE>, <CODE>b</CODE>,
<CODE>"</CODE> and <CODE>c</CODE>.  <CODE>"ab\\c"</CODE> also contains four characters,
<CODE>a</CODE>, <CODE>b</CODE>, <CODE>\</CODE> and <CODE>c</CODE>.  And <CODE>"ab\\\"c"</CODE>
contains five characters <CODE>a</CODE>, <CODE>b</CODE>, <CODE>\</CODE>, <CODE>"</CODE> and
<CODE>c</CODE>.
<DT><EM>Lists or Cons</EM>
<DD>
Lists start with a left parenthesis and end with a right parenthesis
with zero or more s-expression between them.  For example

<PRE>
(a b c)
()
(b (b d) e)
((the boy) saw (the girl (in (the park))))
</PRE>

Lists can be made by various functions most notably <CODE>cons</CODE> and
<CODE>list</CODE>.  <CODE>cons</CODE> returns a list whose first item is the first
item in the list, standardly called its <CODE>car</CODE>, and whose remainder,
standardly called its <CODE>cdr</CODE>, is the second argument of <CODE>cons</CODE>.

<PRE>
(cons 'a '(b c)) =&#62; (a b c)
(cons '(a b) '(c d)) =&#62; ((a b) c d)
</PRE>

<DT><EM>Functions:</EM>
<DD>
Functions may be applied explicity bu the function <CODE>apply</CODE>
or more normally as when the appear as the first item in a list
to be evaluated.  The normal way to define function is using
the <CODE>define</CODE> function.  For example

<PRE>
(define (ftoc temp)
   (/ (* (- temp 32) 5) 9))
</PRE>

This binds the function to the variable <CODE>ftoc</CODE>.  Functions
can also be defined anonymously which sometimes is convinient.

<PRE>
(lambda (temp)
   (/ (* (- temp 32) 5) 9))
</PRE>

returns a function.
<DT><EM>Others:</EM>
<DD>
other internal types are support by Festival's scheme including some
inportant object types use for synthesis such as utterances, waveforms,
items etc.  The are normally printed as in the form

<PRE>
#&#60;Utterance 6234&#62;
#&#60;Wave 1294&#62;
</PRE>

The rpint form is a convinience form only.  Enter that string of
characters will not allow a reference to that object.  The number is
unique to that object instance (it is actually the internal address of
the object), and can be used visually to note if objects are the same or
not.
</DL>



<H2><A NAME="SEC19" HREF="festvox_toc.html#TOC19">6.3  Functions</A></H2>

<P>
This section lists the basic functions in Festival's Scheme.  It doesn't
list them all (see the Festival manual for that) but does highlight the
key functions that you should normally use.

</P>


<H3><A NAME="SEC20" HREF="festvox_toc.html#TOC20">6.3.1  Core functions</A></H3>

<P>
These functions are the basic functions used in Scheme.  These
include the structural functions for setting variables, 
conditionals. loops, etc.

</P>
<DL COMPACT>

<DT><CODE>(set! SYMBOL VALUE)</CODE>
<DD>
Sets <VAR>SYMBOL</VAR> to <VAR>VALUE</VAR>.  <VAR>SYMBOL</VAR> is not evaluated,
while <VAR>VALUE</VAR> is.  Example

<PRE>
(set! a 3)
(set! pi 3.14)
(set! fruit '(apples pears bananas))
(set! fruit2 fruit)
</PRE>

<DT><CODE>(define (FUNCNAME ARG0 ARG1 ...) . BODY)</CODE>
<DD>
define a function called <VAR>FUNCNAME</VAR> with specified arguments and
body.

<PRE>
(define (myadd a b) (+ a b))
(define (factorial a)
 (cond
  ((&#60; a 2) 1)
  (t (* a (factorial (- a 1))))))
</PRE>

<DT><CODE>(if TEST TRUECASE [FALSECASE] )</CODE>
<DD>
If the value of <VAR>TEST</VAR> is non-nil, evaluate <VAR>TRUECASE</VAR> and return
value else if present evaluate <VAR>FALSECASE</VAR> if present and return value,
else return <CODE>nil</CODE>.

<PRE>
(if (string-equal v "apples")
   (format t "It's an apple\n")
   (format t "It's not an apple\n"))
(if (member v '(apples pears bananas))
   (begin
       (format t "It's a fruit (%s)\n" v)
       'fruit)
   'notfruit)
</PRE>

<DT><CODE>(cond (TEST0 . BODY) (TEST1 . BODY) ...)</CODE>
<DD>
A multiple if statement.  Evaluates each <VAR>TEST</VAR> until a non-nil test
is found then evalues each of the expressions in that <VAR>BODY</VAR> return
the value of the last one.

<PRE>
(cond
  ((string-equal v "apple")
   'ringo)
  ((string-equal v "plum")
   'ume)
  ((string-equal v "peach")
   'momo)
  (t
   'kudamono)
</PRE>

<DT><CODE>(begin . BODY )</CODE>
<DD>
This evaluates each s-expression in <VAR>BODY</VAR> and returns the value
of the last s-expression in the list.  This is useful for case
where only one s-expression is expected but you need to call a number
of functions, notably the <CODE>if</CODE> function.

<PRE>
(if (string-equal v "pear")
    (begin
       (format t "assuming it's a asian pear\n")
       'nashi)
    'kudamono)
</PRE>

<DT><CODE>(or . DISJ)</CODE>
<DD>
evalutate each disjunct until one is non-nil and return that value.

<PRE>
(or (string-equal v "tortoise")
    (string-equal v "turtle"))
(or (string-equal v "pear")
    (string-equal v "apple")
    (&#60; num_fruits 6))
</PRE>

<DT><CODE>(and . CONJ)</CODE>
<DD>
evalutate each conjunct until one is nil and return that value or
return the value of the last conjunct.

<PRE>
(and (&#60; num_fruits 10)
     (&#62; num_fruits 3))
(and (string-equal v "pear")
     (&#60; num_fruits 6)
     (or (string-equal day "Tuesday")
         (string-equal day "Wednesday")))
</PRE>

</DL>



<H3><A NAME="SEC21" HREF="festvox_toc.html#TOC21">6.3.2  List functions</A></H3>

<DL COMPACT>

<DT><CODE>(car EXPR)</CODE>
<DD>
returns the "car" of <VAR>EXPR</VAR>, for a list this is the first item,
for an atom or the empty list this is defined to be <CODE>nil</CODE>.

<PRE>
(car '(a b)) =&#62; a
(car '((a b) c d)) =&#62; (a b)
(car '(a (b c) d)) =&#62; a
(car nil) =&#62; nil
(car 'a) =&#62; nil
</PRE>

<DT><CODE>(cdr EXPR)</CODE>
<DD>
returns the "cdr" of <VAR>EXPR</VAR>, for a list this is the rest of the
list, for an atom or the empty list this is defined to be <CODE>nil</CODE>.

<PRE>
(cdr '(a b)) =&#62; (b)
(cdr '((a b) c d)) =&#62; (c d)
(cdr '(a)) =&#62; nil
(cdr '(a (b c))) =&#62; ((b c))
(cdr nil) =&#62; nil
(cdr 'a) =&#62; nil
</PRE>

<DT><CODE>(cons EXPR0 EXPR2)</CODE>
<DD>
build a new list whose "car" is <VAR>EXPR0</VAR> and whose "cdr" is <VAR>EXPR1</VAR>.

<PRE>
(cons 'a '(b c)) =&#62; (a b c)
(cons 'a ()) =&#62; (a)
(cons '(a b) '(c d) =&#62; '((a b) c d))
(cons () '(a) =&#62; '(nil a))
(cons 'a 'b =&#62; (a . b))
(cons nil nil) =&#62; (nil)
</PRE>

<DT><CODE>(list . BODY)</CODE>
<DD>
Form a list from each of the arguments

<PRE>
(list 'a 'b 'c) =&#62; (a b c)
(list '(a b) 'c 'd) =&#62; ((a b) c d)
(list nil '(a b) '(a b)) =&#62; (nil (a b) (a b))
</PRE>

<DT><CODE>(append . BODY)</CODE>
<DD>
Join each of the arguments (lists) into a single list

<PRE>
(append '(a b) '(c d)) =&#62; (a b c d)
(append '(a b) '((c d)) '(e f)) =&#62; (a b (c d) e f)
(append nil nil) =&#62; nil
(append '(a b)) =&#62; (a b))
(append 'a 'b) =&#62; error
</PRE>

<DT><CODE>(nth N LIST)</CODE>
<DD>
Return Nth member of list, the first item is the 0th member.

<PRE>
(nth 0 '(a b c)) =&#62; a
(nth 2 '(a b c)) =&#62; c
(nth 3 '(a b c)) =&#62; nil
</PRE>

<DT><CODE>(nth_cdr N LIST)</CODE>
<DD>
Return Nth cdr list, the first cdr is the 0th member, which is
the list itself.

<PRE>
(nth 0 '(a b c)) =&#62; (a b c)
(nth 2 '(a b c)) =&#62; (c)
(nth 1 '(a b c)) =&#62; (b c)
(nth 3 '(a b c)) =&#62; nil
</PRE>

<DT><CODE>(last LIST)</CODE>
<DD>
The last cdr of a list, traditionally this function has always been called
<CODE>last</CODE> rather <CODE>last_cdr</CODE>

<PRE>
(last '(a b c)) =&#62; (c)
(last '(a b (c d))) =&#62; ((c d))
</PRE>

<DT><CODE>(reverse LIST)</CODE>
<DD>
Return the list in reverse order

<PRE>
(reverse '(a b c)) =&#62; (c b a)
(reverse '(a)) =&#62; (a)
(reverse '(a b (c d))) =&#62; ((c d) b a)
</PRE>

<DT><CODE>(member ITEM LIST)</CODE>
<DD>
Returns the cdr in LIST whose car is ITEM or nil if it found

<PRE>
(member 'b '(a b c)) =&#62; (b c)
(member 'c '(a b c)) =&#62; (c)
(member 'd '(a b c)) =&#62; nil
(member 'b '(a b c b)) =&#62; (b c b)
</PRE>

Note that <CODE>member</CODE> uses <CODE>eq</CODE> to test equality, hence this
does not work for strings.   You should use <CODE>member_string</CODE>
if the list contains strings.
<DT><CODE>(assoc ITEM ALIST)</CODE>
<DD>
a-list are a standard list format for representing feature value
pairs.  An a-list is basically a list of pairs of name and value,
although the name may be any lisp item it is usually an symbol.  A
typlical a-list is

<PRE>
((name AH)
 (duration 0.095)
 (vowel +)
 (occurs ("file01" "file04" "file07" "file24"))
)
</PRE>

<CODE>assoc</CODE> is a function that allows you to look up values
in an a-list

<PRE>
(assoc 'name '((name AH) (duration 0.95))) =&#62; (name AH)
(assoc 'duration '((name AH) (duration 0.95))) =&#62; (duration 0.95)
(assoc 'vowel '((name AH) (duration 0.95))) =&#62; nil
</PRE>

Note that <CODE>assoc</CODE> uses <CODE>eq</CODE> to test equality, hence this
does not work names that are strings.   
You should use <CODE>assoc_string</CODE> if the a-list uses strings for
names.
</DL>



<H3><A NAME="SEC22" HREF="festvox_toc.html#TOC22">6.3.3  Arithmetic functions</A></H3>

<P>
+ - * / exp log sqrt &#60; &#62; &#60;= &#62;= = 

</P>


<H3><A NAME="SEC23" HREF="festvox_toc.html#TOC23">6.3.4  I/O functions</A></H3>

<P>
File names in Festival use the Unix convention of using "/" as the
directory separator.  However under other operating systems, such as
Windows, the "/" will be appropriately mapped into backslash as
required.  For most cases you do not need to worry about this and if you
use forward slash all the time ti will work.

</P>
<DL COMPACT>

<DT><CODE>(format FD FORMATSTRING . ARGS)</CODE>
<DD>
The <CODE>format</CODE> function is a littel unusually in Lisp.  It basically
follows the <CODE>printf</CODE> command in C, or more closely follows the
<CODE>format</CODE> function in Emacs lisp.  It is desgined to print out
infomation that isn;t necessarily to be read in by Lisp (unlike
<CODE>pprint</CODE>, <CODE>print</CODE> and <CODE>printfp</CODE>).  <VAR>FD</VAR> is a file
descriptor as created by <CODE>fopen</CODE>, and the result is printed to
that.  Also two special values are allows there.  <CODE>t</CODE> causes the
output to be sent to standard out (which is usually the terminal).
<CODE>nil</CODE> causes the output to be written to a string and returned by
the function.  Also the variable <CODE>stderr</CODE> is set to a file
descriptor for standard error output.

The format string closely follows the format used in C's printf
functions.  It is actually interpreted by those functions in its
implementation.  <CODE>format</CODE> supports the following directives
<DL COMPACT>

<DT><EM>%d</EM>
<DD>
Print as integer
<DT><EM>%d</EM>
<DD>
Print as integer in hexadecimal
<DT><EM>%f</EM>
<DD>
Print as float
<DT><EM>%s</EM>
<DD>
Convert item to string
<DT><EM>%%</EM>
<DD>
A percent character
<DT><EM>%g</EM>
<DD>
Print as double
<DT><EM>%c</EM>
<DD>
Print number as character
<DT><EM>%l</EM>
<DD>
Print as Lisp object
</DL>
In addition directive sizes are supported, including (zero or space)
padding, and widths.  Explicitly specified sizes as arguments as in
<CODE>%*s</CODE> are not supported, nor is <CODE>%p</CODE> for pointers.

The <CODE>%s</CODE> directive will try to convert the corresponding
lisp argument to a string before passing it to the low level print
function.  Thus list will be printed to strings, and numbers also
coverted.  This form will loose the distinction between lisp symbols 
and lisp strings as the quote will not be present in the <CODE>%s</CODE> 
form.  In general <CODE>%s</CODE> should be used for getting nice human
output and not for machine readable output as it is a lossy print
form.

In contrast <CODE>%l</CODE> is designed to reserve the Lisp forms
so they can be more easily read, quotes will appear and escapes
for embedded quote will be treated properly.

<PRE>
(format t "duration %0.3f\n" 0.12345) =&#62; duration 0.123
(format t "num %d\n" 23) =&#62; num 23
(format t "num %04d\n" 23) =&#62; num 0023
</PRE>

<DT><CODE>(pprintf SEXP [FD])</CODE>
<DD>
Pretty print give expression to standard out (or FD if specified).
Pretty printing is a technique that inserts newlines in the
printout and indentation to make the lisp expression easier to 
read.

<DT><CODE>(fopen FILENAME MODE)</CODE>
<DD>
This creates a file description, which can be used in the various I/O
functions.  It closely follows C stdio <CODE>fopen</CODE> function.  The
mode may be
<DL COMPACT>

<DT><EM>"r"</EM>
<DD>
to open the file for reading
<DT><EM>"w"</EM>
<DD>
to open the file for writing
<DT><EM>"a"</EM>
<DD>
to open the file at the end for writing (so-called, append).
<DT><EM>"b"</EM>
<DD>
File I/O in binary (for OS's that make the distinction),
</DL>
Or any combination of these.
<DT><CODE>(fclose FD)</CODE>
<DD>
Close a file descriptor as created by <CODE>fopen</CODE>.
<DT><CODE>(read)</CODE>
<DD>
Read next s-expression from standard in
<DT><CODE>(readfp FD)</CODE>
<DD>
Read next s-expression from given file descriptor FD.  On end of
file it returns an sexpression eq to the value returned by the
function <CODE>(eof_val)</CODE>.  A typical example use of these
functions is

<PRE>
(let ((ifd (fopen infile "r"))
      (ofd (fopen outfile "w"))
      (word))
   (while (not (equal? (set! word (readfp ifd)) (eof-val)))
      (format ofd "%l\n" (lex.lookup word nil)))
   (fclose ifd)
   (fclose ofd)))
</PRE>

<DT><CODE>(load FILENAME [NOEVAL])</CODE>
<DD>
Load in the s-expressions in <CODE>FILENAME</CODE>.  If <CODE>NOEVAL</CODE> is
unspecified the s-expressions are evaluated as they are read.  If 
<CODE>NOEVAL</CODE> is specified and non-nil, <CODE>load</CODE> will return all
s-expressions in the file un-evaluated in a single list.
</DL>



<H3><A NAME="SEC24" HREF="festvox_toc.html#TOC24">6.3.5  String functions</A></H3>

<P>
As in many other languages, Scheme has a distinction between
<CODE>strings</CODE> and <CODE>symbols</CODE>.  String evaluate to themselves and
cannot be assigned other values, symbols of the print name are
<CODE>equal?</CODE> while strings of teh same name aren't necessarily.

</P>
<P>
In Festival's Scheme, strings are eight bit clean and designed to hold
strings of text and characters in what ever language is being
synthesized.  Strings are always treats as string of 8 bit characters
even though some language may interpret these are 16-bit characters.
Symbols, in general, should not contain 8bit characters.
<DL COMPACT>

<DT><CODE>(string-equal STR1 STR2)</CODE>
<DD>
Finds the string of <CODE>STR1</CODE> and <CODE>STR2</CODE> and returns <CODE>t</CODE> if
these are equal, and <CODE>nil</CODE> otherwise.  Symbol names and numbers are
mapped to string, though you should be aware that the mapping of a
number to a string may not always produce what you hope for.  A number
<CODE>0</CODE> may or may not be mapped to <CODE>"0"</CODE> or maybe to <CODE>"0.0"</CODE>
such that you should not dependent on the mapping.  You can use
<CODE>format</CODE> to map a number ot a string in an explicit manner.  It is
however safe to pass symbol names to <CODE>string-equal</CODE>.  In most cases
<CODE>string-equal</CODE> is the right function to use rather than
<CODE>equal?</CODE> which is must stricter about its definition of equality.

<PRE>
(string-equal "hello" "hello") =&#62; t
(string-equal "hello" "Hello") =&#62; false
(string-equal "hello" 'hello) =&#62; t
</PRE>

<DT><CODE>(string-append . ARGS)</CODE>
<DD>
For each argument coerce it to a string, and return the concatenation of
all arguments.

<PRE>
(string-append "abc" "def") =&#62; "abcdef"
(string-append "/usr/local/" "bin/" "festival") =&#62; "/usr/local/bin/festival"
(string-append "/usr/local/" t 'hello) =&#62; "/usr/local/thello"
(string-append "abc") =&#62; "abc"
(string-append ) =&#62; ""
</PRE>

<DT><CODE>(member_string STR LIST)</CODE>
<DD>
returns <CODE>nil</CODE> if no member of <CODE>LIST</CODE> is <CODE>string-equal</CODE> to
<CODE>STR</CODE>, otherwise it returns <CODE>t</CODE>.  Again, this is often the
safe way to check membership of a list as this will work properly if
<CODE>STR</CODE> or the members of <CODE>LIST</CODE> are symbols or strings.

<PRE>
(member_string "a" '("b" "a" "c")) =&#62; t
(member_string "d" '("b" "a" "c")) =&#62; nil
(member_string "d" '(a b c d)) =&#62; t
(member_string 'a '("b" "a" "c")) =&#62; t
</PRE>

<DT><CODE>(string-before STR SUBSTR)</CODE>
<DD>
Returns the initial prefix of <CODE>STR</CODE> up to the first occurrence
of <CODE>SUBSTR</CODE> in <CODE>STR</CODE>.  If <CODE>SUBSTR</CODE> doesn't
exist within <CODE>STR</CODE> the empty string is returned.

<PRE>
(string-before "abcd" "c") =&#62; "ab"
(string-before "bin/make_labs" "/") =&#62; "bin"
(string-before "usr/local/bin/make_labs" "/") =&#62; "usr"
(string-before "make_labs" "/") =&#62; ""
</PRE>

<DT><CODE>(string-after STR SUBSTR)</CODE>
<DD>
Returns the longest suffix of <CODE>STR</CODE> after the first occurrence
of <CODE>SUBSTR</CODE> in <CODE>STR</CODE>.  If <CODE>SUBSTR</CODE> doesn't
exist within <CODE>STR</CODE> the empty string is returned.

<PRE>
(string-after "abcd" "c") =&#62; "d"
(string-after "bin/make_labs" "/") =&#62; "make_labs"
(string-after "usr/bin/make_labs" "/") =&#62; "bin/make_labs"
(string-after "make_labs" "/") =&#62; ""
</PRE>

<DT><CODE>(length STR)</CODE>
<DD>
Returns the lengh of given string (or list).  Length does not coerce its
argument into a string, hence given a symbol as argument is an error.

<PRE>
(length "") =&#62; 0
(length "abc") =&#62; 3
(length 'abc) -&#62; SIOD ERROR
(length '(a b c)) -&#62; 3
</PRE>

<DT><CODE>(symbolexplode SYMBOL)</CODE>
<DD>
returns a list of single character strings for each character in
<CODE>SYMBOL</CODE>'s print name.  This will also work on strings.

<PRE>
(symbolexplode 'abc) =&#62; ("a" "b" "c")
(symbolexplode 'hello) =&#62; ("h" "e" "l" "l" "o")
</PRE>

<DT><CODE>(intern STR)</CODE>
<DD>
Convert a string into a symbol with the same print name.
<DT><CODE>(string-matches STR REGEX)</CODE>
<DD>
Returns <CODE>t</CODE> if <CODE>STR</CODE> matches <CODE>REGEX</CODE> regular expression.
Regular expressions are described more fully below.

<PRE>
(string-matches "abc" "a.*") =&#62; t
(string-matches "hello" "[Hh]ello") =&#62; t
</PRE>

</DL>



<H3><A NAME="SEC25" HREF="festvox_toc.html#TOC25">6.3.6  System functions</A></H3>

<P>
In order to interact more easily with the underlying operating system,
Festival Scheme includes a number of basic function that allow Scheme
programs to make use of the operating system functions.
<DL COMPACT>

<DT><CODE>(system COMMAND)</CODE>
<DD>
Evaluates the command with the Unix shell (or equivalent).  Its
not clear how this should (or does0 work on other operating systems
so it should be used sparingly if the code is to be portable.

<PRE>
(system "ls") =&#62; lists files in current directory.
(system (format nil "cat %s" filename))
</PRE>

<DT><CODE>(get_url URL OFILE)</CODE>
<DD>
Copies contents of <CODE>URL</CODE> into <CODE>OFILE</CODE>.  It support
<TT>`file:'</TT> and <TT>`http:'</TT> prefixes, but current does not support the
<CODE>ftp:</CODE> protocol.  

<PRE>
(get_url "http://www.cstr.ed.ac.uk/projects/festival.html" "festival.html")
</PRE>

<DT><CODE>(setenv NAME VALUE)</CODE>
<DD>
Set environment variable <CODE>NAME</CODE> to <CODE>VALUE</CODE> which should 
be strings

<PRE>
(setenv "DISPLAY" "nara.mt.cs.cmu.edu:0.0")
</PRE>

<DT><CODE>(getenv NAME)</CODE>
<DD>
Get value of environment variable <CODE>NAME</CODE>.

<PRE>
(getenv "DISPLAY")
</PRE>

<DT><CODE>(getpid)</CODE>
<DD>
The process id, as a number.  This is useful when creating
files that need to be unique for the festival instance.

<PRE>
(set! bbbfile (format nil "/tmp/stuff.%05d" (getpid)))
</PRE>

<DT><CODE>(cd DIRECTORY)</CODE>
<DD>
Change directory.

<PRE>
(cd "/tmp")
</PRE>

<DT><CODE>(pwd)</CODE>
<DD>
return a string which is a pathname to the current working directory.
</DL>



<H3><A NAME="SEC26" HREF="festvox_toc.html#TOC26">6.3.7  Utterance Functions</A></H3>



<H3><A NAME="SEC27" HREF="festvox_toc.html#TOC27">6.3.8  Synthesis Functions</A></H3>



<H2><A NAME="SEC28" HREF="festvox_toc.html#TOC28">6.4  Debugging and Help</A></H2>



<H2><A NAME="SEC29" HREF="festvox_toc.html#TOC29">6.5  Adding new C++ functions to Scheme</A></H2>



<H2><A NAME="SEC30" HREF="festvox_toc.html#TOC30">6.6  Regular Expressions</A></H2>

<P>
Regular expressions are fundamentally useful in any text processing
language.  This is also true in Festival's Scheme.  The function
<CODE>string-matches</CODE> and a number of other places (notably CART trees)
allow th eunse of regular expressions to matche strings.

</P>
<P>
We will not go into the formal aspects of regular expressions
but just give enough discussion to help you use them here.  See
<CITE>regexbook</CITE> for probablay more information than you'll ever
need.

</P>
<P>
Each implementation of regex's may be slightly different hence here we
will lay out the full syntaxt and semantics of the our regex patterns.
This is not an arbitrary selection, when Festival was first developed we
use the GNU libg++ <CODE>Regex</CODE> class but for portability to non-GNU
systems we had replace that with our own impelementation based on Henry
Spencer regex code (which is at the core of many regex libraries).

</P>
<P>
In general all character match themselves except for the following
which (can) have special interpretations

<PRE>
. * + ? [ ] - ( ) | ^ $ \
</PRE>

<P>
If these are preceded by a backslash then they no longer will have
special interpretation.
<DL COMPACT>

<DT><CODE>.</CODE>
<DD>
Matches any character.

<PRE>
(string-matches "abc" "a.c") =&#62; t
(string-matches "acc" "a.c") =&#62; t
</PRE>

<DT><CODE>*</CODE>
<DD>
Matches zero or more occurrences of the preceding item in the regex

<PRE>
(string-matches "aaaac" "a*c") =&#62; t
(string-matches "c" "a*c") =&#62; t
(string-matches "anythingc" ".*c") =&#62; t
(string-matches "canythingatallc" "c.*c") =&#62; t
</PRE>

<DT><CODE>+</CODE>
<DD>
Matches one or more occurrences of the preceding item in the regex

<PRE>
(string-matches "aaaac" "a+c") =&#62; t
(string-matches "c" "a*c") =&#62; nil
(string-matches "anythingc" ".+c") =&#62; t
(string-matches "c" ".+c") =&#62; nil
(string-matches "canythingatallc" "c.+c") =&#62; t
(string-matches "cc" "c.+c") =&#62; nil
</PRE>

<DT><CODE>?</CODE>
<DD>
Matches zero or one occurrences of the preceding item.  This
is it makes the preceding item optional.

<PRE>
(string-matches "abc" "ab?c") =&#62; t
(string-matches "ac" "ab?c") =&#62; t
</PRE>

<DT><CODE>[ ]</CODE>
<DD>
can defined a set of characters.  This can also be used to defined
a range.  For example <CODE>[aeiou]</CODE> is and lower case vowel, <CODE>[a-z]</CODE>
is an lower case letter from a thru z.  <CODE>[a-zA-Z]</CODE> is any character
upper or lower case.

If the <CODE>^</CODE> is specifed first it negates the class, thus
<CODE>[^a-z]</CODE> matches anything but a lower case character.
</DL>



<H2><A NAME="SEC31" HREF="festvox_toc.html#TOC31">6.7  Some Examples</A></H2>

<P><HR><P>
Go to the <A HREF="festvox_1.html">first</A>, <A HREF="festvox_5.html">previous</A>, <A HREF="festvox_7.html">next</A>, <A HREF="festvox_21.html">last</A> section, <A HREF="festvox_toc.html">table of contents</A>.
</BODY>
</HTML>
